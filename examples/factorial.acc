

/* IO function, implemented by external runtime.
 */
fn %read_i64() -> i64;

fn %write_i64(#value: i64) -> ();


fn %factorial(#n: i64) -> i64 {
Lentry:
    /* Create a stack slot of i64 type as the space of the return value.
     * if n equals 1, store `1` to this address, i.e. `return 1`,
     * otherwise, do recursive call, i.e. return n * factorial(n - 1).
     */
    let %ret.addr: i64* = alloca i64, 1
    let %cmp: i1 = eq #n: i64, 0
    br i1 %cmp, label Ltrue, Lfalse
Ltrue:
    let %6: () = store 1, %ret.addr
    jmp label Lret
Lfalse:
    let %9: i64 = sub #n: i64, 1
    let %res: i64 = call fn %factorial, %9
    let %11: i64 = mul %9, %res
    let %12: () = store %11: i64, %ret.addr
    jmp label Lret
Lret:
    let %ret.val: i64 = load %ret.addr: i64*
    ret %ret.val: i64
}

fn %main() -> () {
Lentry:
    let %n: i64 = call fn %read_i64
    let %res = call fn %factorial, %n
    let %4 = call fn %write_i64, %res
    ret ()
}
