

/* IO function, implemented by external runtime.
 */
fn %read_i32() -> i32;

fn %write_i32(#value: i32) -> ();


fn %factorial(#n: i32) -> i32 {
%Lentry:
    /* Create a stack slot of i32 type as the space of the return value.
     * if n equals 1, store `1` to this address, i.e. `return 1`,
     * otherwise, do recursive call, i.e. return n * factorial(n - 1).
     */
    let %ret.addr: i32* = alloca i32, 1
    let %cmp: i1 = eq #n: i32, 0
    br i1 %cmp, label %Ltrue, label %Lfalse
%Ltrue:
    let %6: () = store 1, %ret.addr
    jmp label %Lret
%Lfalse:
    let %9: i32 = sub #n: i32, 1
    let %res: i32 = call fn %factorial, %9
    let %11: i32 = mul %9, %res
    let %12: () = store %11: i32, %ret.addr
    jmp label %Lret
%Lret:
    let %ret.val: i32 = load %ret.addr: i32*
    ret %ret.val: i32
}

fn %main() -> () {
%Lentry:
    let %n: i32 = call fn %read_i32
    let %res = call fn %factorial, %n
    let %4 = call fn %write_i32, %res
    ret ()
}
